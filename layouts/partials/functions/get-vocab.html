<!-- Get a new scratch. -->
{{ $s := newScratch }}

<!-- Get the content of the html file which is export of WorkFlowy. -->
{{ with .Page.Resources.GetMatch "*.html" }}
    <!-- TODO cache but only if resource has changed -->

    <!--
        Clean up the vocabulary export:
        - delete line breaks
        - remove spaces between tags
        - remove first and last part
        - delete tags to be ignored
    -->
    {{ $wf := .Content | replaceRE "\r\n" "" | replaceRE ">\\s+<" "><" | replaceRE ".*<body><outline[^>]*>|<outline text=\"\\*[^>]+\" />|</outline></body></opml>" ""  }}

    <!-- Get all ending branches that are vocabulary words. -->
    {{ range findRE "<outline[^>]*_[^>]*/>" $wf }}
        {{ $wf = replace $wf . "" }}
        {{ $s.Add "tags" (slice .)}}
    {{ end }}

    {{ range seq 5 }}

        <!-- Get all vocabulary word lists. -->
        {{ range findRE "<outline text=\"\\*[^>]+\">(<outline[^>]*/>){0,}</outline>" $wf }}
            {{ $wf = replace $wf . "" }}
            {{ range findRE "<outline[^>]*/>" . }}
                {{ $s.Add "tags" (slice .)}}
            {{ end }}
        {{ end }}

        <!-- Get all vocabulary words with examples and without further branches. -->
        {{ range findRE "<outline[^>]*><outline text=\"\\*\">(<outline[^>]*/>){1,}(</outline>){2}|<outline text=\"[^>]*_\\s?\">(<outline[^>]*/>){1,}</outline>" $wf }}
            {{ $wf = replace $wf . "" }}
            {{ $s.Add "tags" (slice .)}}
        {{ end }}

        {{ range findRE "<outline text=\"[^>]*\"></outline>" $wf }}
            {{ $wf = replace $wf . "" }}
            {{ $s.Add "tags" (slice .)}}
        {{ end }}
    {{ end }}

    <!-- DEBUG -->
    {{ if $wf }}
        <p>I need more iterations to parse the vocabulary.</p>
    {{ end }}

    {{ range $s.Get "tags" }}
        <!-- Get the initial text. -->
        {{ $text := . | replaceRE "\\A<outline text=\"(.*?)\".*" "$1"  }}

        {{ if not (findRE "\\A\\*" $text) }}
            {{ $s.SetInMap $text "text" $text }}

            <!-- Get the only example. -->
            {{ if in $text "_" }}
                {{ $example := $text | replaceRE ".*_\\s*" "" }}
                {{ with $example }}
                    {{ $s.Add "examples" (slice .) }}
                {{ end }}

                {{ $text = $text | replaceRE "\\s*_.*" "" }}
            {{ end }}

            <!-- Get the regex. -->
            {{ if in $text ":" }}
                {{ $regexes := $text | replaceRE ".*:\\s*" "" }}
                {{ with $regexes }}
                    {{ $s.Add "regexes" (split $regexes "|") }}
                {{ else }}
                    <p>In '{{ $text }}', found no regexes despite there being a colon.</p>
                {{ end }}

                {{ $text = $text | replaceRE "\\s*:.*" "" }}
            {{ end }}

            <!-- Get further examples. -->
            {{ $rest := . | replaceRE "\\A[^>]*>" "" }}
            {{ range findRE "<outline[^>\\*]*>" $rest }}
                {{ $example := . | replaceRE "\\A<outline text=\"(.*?)\".*" "$1"  }}
                {{ $s.Add "examples" (slice $example) }}
            {{ end }}

            <!-- DEBUG -->
            {{ $s.SetInMap $text "text" $text }}

            <!-- Add the examples to the map. -->
            {{ with $s.Get "examples" }}
                {{ $s.SetInMap $text "examples" . }}
                {{ $s.Delete "examples" }}
            {{ end }}

            <!-- Get the most basic version. -->
            {{ $basic := $text | replaceRE "\\A\\(sich\\) |\\Asich |\\Ader |\\Adie |\\Adas |\\Ader/die |\\Adas/der/die | \\(pl\\.\\)\\z|,\\s*-[^\\/]*|, –\\z|\\(.*?\\)" "" | replaceRE "/die |/das " "/" | replaceRE "\\A\\s+|\\s+\\z" "" }}
            {{ if not $basic }}
                <p>Could not find basic word for '{{ $text }}'.</p>
            {{ end }}

            <!-- 
                Find alternatives.
                Example: Viertel vor/nach zwei
                    $alt = "vor/nach"
                    split = [vor,nach]
                    Then replace "vor/nach" with "vor" or with "nach".
                Example: zum Beispiel/z. B.: zum Beispiel|z. B.
                    $basic = "zum Beispiel/z. B."
                    split = [zum Beispiel,z. B.]
            -->
            {{ if and (in $basic "/") (not ($s.Get "regexes")) }}
                {{ range $both := findRE "[^\\s]*/[^\\s]*" $basic }}
                    {{ range split . "/" }}
                        {{ $alt := replace $basic $both . }}
                        {{ $s.Add "alts" (slice $alt) }}
                        {{ $s.Add "variants" (slice $alt) }}
                    {{ end }}
                {{ end }}
            {{ else if and (findRE "[^ ]-\\z:" $basic) ($s.Get "regexes") }}
                <!-- Found matches like "lieb-: liebe|lieber", use the regex instead of "lieb-". -->
                {{ $s.Add "alts" ($s.Get "regexes") }}
                
                <!-- Transform dash into regex. -->
                {{ $reg := $basic | replaceRE "-\\z" ".+" }}
                {{ $s.Add "regexes" (slice $reg) }}
            {{ else }}
                {{ range split $basic "/" }}
                    {{ $s.Add "alts" (slice .) }}
                    {{ $s.Add "variants" (slice .) }}
                {{ end }}
            {{ end }}

            {{ range $alt := $s.Get "alts"}}
                <!-- Add the variants to the map and to a variable. -->
                {{ with (partial "functions/get-word-info" $alt).de }}
                    {{ range .variants }}
                        {{ $s.Add "variants" (slice .) }}
                    {{ end }}

                    <!-- Add female version. -->
                    {{ if in (index . "word classes") "Substantiv"}}
                        {{ range (index .entries 0).subentries }}
                            {{ if eq .header.de "Weibliche Wortformen" }}
                                {{ $female := .subentry | replaceRE "<[^>]*>|\\[.*?\\]\\s*" "" }}
                                {{ $s.Add "variants" (slice $female) }}
                            {{ end }}
                        {{ end }}
                    {{ end }}
                {{ end }}
            {{ end }}
            
            {{ $s.Set "variants" (uniq ($s.Get "variants")) }}

            <!-- DEBUG -->
            {{ if not (findRE "[^ ]-\\z" $basic) }}
                {{ range $s.Get "regexes" }}
                    {{ if in ($s.Get "variants") . }}
                        <p>No need to put '{{ . }}' in regexes of '{{ $basic }}', it's already a known variant.</p>
                    {{ end }}
                {{ end }}
            {{ end }}

            <!-- Add variants to potential regexes. -->
            {{ $s.Add "regexes" ($s.Get "variants") }}

            <!-- Calculate regexes. -->
            {{ range $s.Get "regexes" }}
                <!-- Transform dot into regex but leave dot with asterisk or plus. -->
                {{ $reg := . | replaceRE "\\.([^\\*\\+\\\\]|\\z)" "\\.$1" | replaceRE "\\.\\*" "\\b.{0,20}" | replaceRE "\\.\\+" "[^\\s]+" }}

                <!--
                    Add word end signifier.
                    Does not work with umlauts.
                -->
                {{ if not (findRE "[öäüßé\\.]\\z" .) }}
                    {{ $reg = $reg | printf "%s\\b" }}
                {{ end }}
                {{ if not (findRE "\\A[ÄÖÜöäü]" .) }}
                    {{ $reg = $reg | print "\\b" }}
                {{ end }}

                {{ $s.Add "regs" (slice $reg) }}
            {{ end }}

            {{ $s.SetInMap $text "variants" ($s.Get "variants") }}
            {{ $s.Delete "variants" }}

            {{ $regex := print "(" (delimit ($s.Get "regs") "|") ")" }}
            {{ $s.SetInMap $text "regex" $regex }}
            {{ $s.Delete "regexes" }}
            {{ $s.Delete "regs" }}

            {{ $s.Add "vocab" (slice ($s.Get $text)) }}
        {{ end }}
    {{ end }}
{{ end }}

{{ return ($s.Get "vocab") }}